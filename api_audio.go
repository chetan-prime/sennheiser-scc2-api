/*
TCC M 3rd party API Release

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.6
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AudioAPIService AudioAPI service
type AudioAPIService service

type ApiApiAudioEqualizerGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioEqualizerGetRequest) Execute() (*ApiAudioEqualizerGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioEqualizerGetExecute(r)
}

/*
ApiAudioEqualizerGet Get the current equalizer settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioEqualizerGetRequest
*/
func (a *AudioAPIService) ApiAudioEqualizerGet(ctx context.Context) ApiApiAudioEqualizerGetRequest {
	return ApiApiAudioEqualizerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioEqualizerGet200Response
func (a *AudioAPIService) ApiAudioEqualizerGetExecute(r ApiApiAudioEqualizerGetRequest) (*ApiAudioEqualizerGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioEqualizerGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioEqualizerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/equalizer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioEqualizerPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioEqualizerPutRequest *ApiAudioEqualizerPutRequest
}

func (r ApiApiAudioEqualizerPutRequest) ApiAudioEqualizerPutRequest(apiAudioEqualizerPutRequest ApiAudioEqualizerPutRequest) ApiApiAudioEqualizerPutRequest {
	r.apiAudioEqualizerPutRequest = &apiAudioEqualizerPutRequest
	return r
}

func (r ApiApiAudioEqualizerPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioEqualizerPutExecute(r)
}

/*
ApiAudioEqualizerPut Set the current equalizer settings

Set the current equalizer settings. Can be applied to a specific output with the `equalizerEnabled` property. Note that all equalizers share the same settings from this route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioEqualizerPutRequest
*/
func (a *AudioAPIService) ApiAudioEqualizerPut(ctx context.Context) ApiApiAudioEqualizerPutRequest {
	return ApiApiAudioEqualizerPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioEqualizerPutExecute(r ApiApiAudioEqualizerPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioEqualizerPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/equalizer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioEqualizerPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioInputsDanteReferenceGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioInputsDanteReferenceGetRequest) Execute() (*ApiAudioInputsDanteReferenceGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioInputsDanteReferenceGetExecute(r)
}

/*
ApiAudioInputsDanteReferenceGet Get settings of the reference input

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsDanteReferenceGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsDanteReferenceGet(ctx context.Context) ApiApiAudioInputsDanteReferenceGetRequest {
	return ApiApiAudioInputsDanteReferenceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioInputsDanteReferenceGet200Response
func (a *AudioAPIService) ApiAudioInputsDanteReferenceGetExecute(r ApiApiAudioInputsDanteReferenceGetRequest) (*ApiAudioInputsDanteReferenceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioInputsDanteReferenceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsDanteReferenceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/dante/reference"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsDanteReferencePutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioInputsDanteReferencePutRequest *ApiAudioInputsDanteReferencePutRequest
}

func (r ApiApiAudioInputsDanteReferencePutRequest) ApiAudioInputsDanteReferencePutRequest(apiAudioInputsDanteReferencePutRequest ApiAudioInputsDanteReferencePutRequest) ApiApiAudioInputsDanteReferencePutRequest {
	r.apiAudioInputsDanteReferencePutRequest = &apiAudioInputsDanteReferencePutRequest
	return r
}

func (r ApiApiAudioInputsDanteReferencePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioInputsDanteReferencePutExecute(r)
}

/*
ApiAudioInputsDanteReferencePut Set reference input settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsDanteReferencePutRequest
*/
func (a *AudioAPIService) ApiAudioInputsDanteReferencePut(ctx context.Context) ApiApiAudioInputsDanteReferencePutRequest {
	return ApiApiAudioInputsDanteReferencePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioInputsDanteReferencePutExecute(r ApiApiAudioInputsDanteReferencePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsDanteReferencePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/dante/reference"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioInputsDanteReferencePutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophoneBeamDirectionGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioInputsMicrophoneBeamDirectionGetRequest) Execute() (*ApiAudioInputsMicrophoneBeamDirectionGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophoneBeamDirectionGetExecute(r)
}

/*
ApiAudioInputsMicrophoneBeamDirectionGet Get the current direction of the beam

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsMicrophoneBeamDirectionGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophoneBeamDirectionGet(ctx context.Context) ApiApiAudioInputsMicrophoneBeamDirectionGetRequest {
	return ApiApiAudioInputsMicrophoneBeamDirectionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioInputsMicrophoneBeamDirectionGet200Response
func (a *AudioAPIService) ApiAudioInputsMicrophoneBeamDirectionGetExecute(r ApiApiAudioInputsMicrophoneBeamDirectionGetRequest) (*ApiAudioInputsMicrophoneBeamDirectionGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioInputsMicrophoneBeamDirectionGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophoneBeamDirectionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/beam/direction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophoneBeamGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioInputsMicrophoneBeamGetRequest) Execute() (*ApiAudioInputsMicrophoneBeamGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophoneBeamGetExecute(r)
}

/*
ApiAudioInputsMicrophoneBeamGet Get the current beam settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsMicrophoneBeamGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophoneBeamGet(ctx context.Context) ApiApiAudioInputsMicrophoneBeamGetRequest {
	return ApiApiAudioInputsMicrophoneBeamGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioInputsMicrophoneBeamGet200Response
func (a *AudioAPIService) ApiAudioInputsMicrophoneBeamGetExecute(r ApiApiAudioInputsMicrophoneBeamGetRequest) (*ApiAudioInputsMicrophoneBeamGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioInputsMicrophoneBeamGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophoneBeamGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/beam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophoneBeamPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioInputsMicrophoneBeamPutRequest *ApiAudioInputsMicrophoneBeamPutRequest
}

func (r ApiApiAudioInputsMicrophoneBeamPutRequest) ApiAudioInputsMicrophoneBeamPutRequest(apiAudioInputsMicrophoneBeamPutRequest ApiAudioInputsMicrophoneBeamPutRequest) ApiApiAudioInputsMicrophoneBeamPutRequest {
	r.apiAudioInputsMicrophoneBeamPutRequest = &apiAudioInputsMicrophoneBeamPutRequest
	return r
}

func (r ApiApiAudioInputsMicrophoneBeamPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophoneBeamPutExecute(r)
}

/*
ApiAudioInputsMicrophoneBeamPut Set the current beam settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsMicrophoneBeamPutRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophoneBeamPut(ctx context.Context) ApiApiAudioInputsMicrophoneBeamPutRequest {
	return ApiApiAudioInputsMicrophoneBeamPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioInputsMicrophoneBeamPutExecute(r ApiApiAudioInputsMicrophoneBeamPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophoneBeamPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/beam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioInputsMicrophoneBeamPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophoneExclusionZonesGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioInputsMicrophoneExclusionZonesGetRequest) Execute() ([]ApiAudioInputsMicrophoneExclusionZonesGet200ResponseInner, *http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophoneExclusionZonesGetExecute(r)
}

/*
ApiAudioInputsMicrophoneExclusionZonesGet Get the supported exclusion zone ids

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsMicrophoneExclusionZonesGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophoneExclusionZonesGet(ctx context.Context) ApiApiAudioInputsMicrophoneExclusionZonesGetRequest {
	return ApiApiAudioInputsMicrophoneExclusionZonesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApiAudioInputsMicrophoneExclusionZonesGet200ResponseInner
func (a *AudioAPIService) ApiAudioInputsMicrophoneExclusionZonesGetExecute(r ApiApiAudioInputsMicrophoneExclusionZonesGetRequest) ([]ApiAudioInputsMicrophoneExclusionZonesGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiAudioInputsMicrophoneExclusionZonesGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophoneExclusionZonesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/exclusionZones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophoneExclusionZonesIdGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	id int32
}

func (r ApiApiAudioInputsMicrophoneExclusionZonesIdGetRequest) Execute() (*ApiAudioInputsMicrophoneExclusionZonesIdGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophoneExclusionZonesIdGetExecute(r)
}

/*
ApiAudioInputsMicrophoneExclusionZonesIdGet Get the current exclusion zone settings of zone number `id`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiApiAudioInputsMicrophoneExclusionZonesIdGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophoneExclusionZonesIdGet(ctx context.Context, id int32) ApiApiAudioInputsMicrophoneExclusionZonesIdGetRequest {
	return ApiApiAudioInputsMicrophoneExclusionZonesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApiAudioInputsMicrophoneExclusionZonesIdGet200Response
func (a *AudioAPIService) ApiAudioInputsMicrophoneExclusionZonesIdGetExecute(r ApiApiAudioInputsMicrophoneExclusionZonesIdGetRequest) (*ApiAudioInputsMicrophoneExclusionZonesIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioInputsMicrophoneExclusionZonesIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophoneExclusionZonesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/exclusionZones/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return localVarReturnValue, nil, reportError("id must be greater than 0")
	}
	if r.id > 4 {
		return localVarReturnValue, nil, reportError("id must be less than 4")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	id int32
	apiAudioInputsMicrophoneExclusionZonesIdPutRequest *ApiAudioInputsMicrophoneExclusionZonesIdPutRequest
}

func (r ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest) ApiAudioInputsMicrophoneExclusionZonesIdPutRequest(apiAudioInputsMicrophoneExclusionZonesIdPutRequest ApiAudioInputsMicrophoneExclusionZonesIdPutRequest) ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest {
	r.apiAudioInputsMicrophoneExclusionZonesIdPutRequest = &apiAudioInputsMicrophoneExclusionZonesIdPutRequest
	return r
}

func (r ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophoneExclusionZonesIdPutExecute(r)
}

/*
ApiAudioInputsMicrophoneExclusionZonesIdPut Set the current exclusion zone settings of zone number `id`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophoneExclusionZonesIdPut(ctx context.Context, id int32) ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest {
	return ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioInputsMicrophoneExclusionZonesIdPutExecute(r ApiApiAudioInputsMicrophoneExclusionZonesIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophoneExclusionZonesIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/exclusionZones/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return nil, reportError("id must be greater than 0")
	}
	if r.id > 4 {
		return nil, reportError("id must be less than 4")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioInputsMicrophoneExclusionZonesIdPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophoneLevelGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioInputsMicrophoneLevelGetRequest) Execute() (*ApiAudioInputsMicrophoneLevelGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophoneLevelGetExecute(r)
}

/*
ApiAudioInputsMicrophoneLevelGet Get the current microphone input level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsMicrophoneLevelGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophoneLevelGet(ctx context.Context) ApiApiAudioInputsMicrophoneLevelGetRequest {
	return ApiApiAudioInputsMicrophoneLevelGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioInputsMicrophoneLevelGet200Response
func (a *AudioAPIService) ApiAudioInputsMicrophoneLevelGetExecute(r ApiApiAudioInputsMicrophoneLevelGetRequest) (*ApiAudioInputsMicrophoneLevelGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioInputsMicrophoneLevelGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophoneLevelGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/level"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophonePriorityZonesGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioInputsMicrophonePriorityZonesGetRequest) Execute() ([]ApiAudioInputsMicrophonePriorityZonesGet200ResponseInner, *http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophonePriorityZonesGetExecute(r)
}

/*
ApiAudioInputsMicrophonePriorityZonesGet Get the supported priority zone ids

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsMicrophonePriorityZonesGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophonePriorityZonesGet(ctx context.Context) ApiApiAudioInputsMicrophonePriorityZonesGetRequest {
	return ApiApiAudioInputsMicrophonePriorityZonesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApiAudioInputsMicrophonePriorityZonesGet200ResponseInner
func (a *AudioAPIService) ApiAudioInputsMicrophonePriorityZonesGetExecute(r ApiApiAudioInputsMicrophonePriorityZonesGetRequest) ([]ApiAudioInputsMicrophonePriorityZonesGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiAudioInputsMicrophonePriorityZonesGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophonePriorityZonesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/priorityZones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophonePriorityZonesIdGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	id int32
}

func (r ApiApiAudioInputsMicrophonePriorityZonesIdGetRequest) Execute() (*ApiAudioInputsMicrophonePriorityZonesIdGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophonePriorityZonesIdGetExecute(r)
}

/*
ApiAudioInputsMicrophonePriorityZonesIdGet Get the current priority zone settings of zone number `id`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiApiAudioInputsMicrophonePriorityZonesIdGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophonePriorityZonesIdGet(ctx context.Context, id int32) ApiApiAudioInputsMicrophonePriorityZonesIdGetRequest {
	return ApiApiAudioInputsMicrophonePriorityZonesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApiAudioInputsMicrophonePriorityZonesIdGet200Response
func (a *AudioAPIService) ApiAudioInputsMicrophonePriorityZonesIdGetExecute(r ApiApiAudioInputsMicrophonePriorityZonesIdGetRequest) (*ApiAudioInputsMicrophonePriorityZonesIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioInputsMicrophonePriorityZonesIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophonePriorityZonesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/priorityZones/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return localVarReturnValue, nil, reportError("id must be greater than 0")
	}
	if r.id > 0 {
		return localVarReturnValue, nil, reportError("id must be less than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	id int32
	apiAudioInputsMicrophonePriorityZonesIdPutRequest *ApiAudioInputsMicrophonePriorityZonesIdPutRequest
}

func (r ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest) ApiAudioInputsMicrophonePriorityZonesIdPutRequest(apiAudioInputsMicrophonePriorityZonesIdPutRequest ApiAudioInputsMicrophonePriorityZonesIdPutRequest) ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest {
	r.apiAudioInputsMicrophonePriorityZonesIdPutRequest = &apiAudioInputsMicrophonePriorityZonesIdPutRequest
	return r
}

func (r ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioInputsMicrophonePriorityZonesIdPutExecute(r)
}

/*
ApiAudioInputsMicrophonePriorityZonesIdPut Set the current priority zone settings of zone number `id`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest
*/
func (a *AudioAPIService) ApiAudioInputsMicrophonePriorityZonesIdPut(ctx context.Context, id int32) ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest {
	return ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioInputsMicrophonePriorityZonesIdPutExecute(r ApiApiAudioInputsMicrophonePriorityZonesIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsMicrophonePriorityZonesIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/microphone/priorityZones/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return nil, reportError("id must be greater than 0")
	}
	if r.id > 0 {
		return nil, reportError("id must be less than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioInputsMicrophonePriorityZonesIdPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioInputsReferenceLevelGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioInputsReferenceLevelGetRequest) Execute() (*ApiAudioInputsReferenceLevelGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioInputsReferenceLevelGetExecute(r)
}

/*
ApiAudioInputsReferenceLevelGet Get the current level of the digital reference input

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioInputsReferenceLevelGetRequest
*/
func (a *AudioAPIService) ApiAudioInputsReferenceLevelGet(ctx context.Context) ApiApiAudioInputsReferenceLevelGetRequest {
	return ApiApiAudioInputsReferenceLevelGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioInputsReferenceLevelGet200Response
func (a *AudioAPIService) ApiAudioInputsReferenceLevelGetExecute(r ApiApiAudioInputsReferenceLevelGetRequest) (*ApiAudioInputsReferenceLevelGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioInputsReferenceLevelGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioInputsReferenceLevelGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/inputs/reference/level"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioNoiseGateGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioNoiseGateGetRequest) Execute() (*ApiAudioNoiseGateGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioNoiseGateGetExecute(r)
}

/*
ApiAudioNoiseGateGet Get the current noise gate settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioNoiseGateGetRequest
*/
func (a *AudioAPIService) ApiAudioNoiseGateGet(ctx context.Context) ApiApiAudioNoiseGateGetRequest {
	return ApiApiAudioNoiseGateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioNoiseGateGet200Response
func (a *AudioAPIService) ApiAudioNoiseGateGetExecute(r ApiApiAudioNoiseGateGetRequest) (*ApiAudioNoiseGateGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioNoiseGateGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioNoiseGateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/noiseGate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioNoiseGatePutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioNoiseGatePutRequest *ApiAudioNoiseGatePutRequest
}

func (r ApiApiAudioNoiseGatePutRequest) ApiAudioNoiseGatePutRequest(apiAudioNoiseGatePutRequest ApiAudioNoiseGatePutRequest) ApiApiAudioNoiseGatePutRequest {
	r.apiAudioNoiseGatePutRequest = &apiAudioNoiseGatePutRequest
	return r
}

func (r ApiApiAudioNoiseGatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioNoiseGatePutExecute(r)
}

/*
ApiAudioNoiseGatePut Set the current noise gate settings

Set the current noise gate settings. Can be applied to a specific output with the `noiseGateEnabled` property. Note that all noise gates share the same settings from this route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioNoiseGatePutRequest
*/
func (a *AudioAPIService) ApiAudioNoiseGatePut(ctx context.Context) ApiApiAudioNoiseGatePutRequest {
	return ApiApiAudioNoiseGatePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioNoiseGatePutExecute(r ApiApiAudioNoiseGatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioNoiseGatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/noiseGate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioNoiseGatePutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioOutputsAnalogGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioOutputsAnalogGetRequest) Execute() (*ApiAudioOutputsAnalogGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioOutputsAnalogGetExecute(r)
}

/*
ApiAudioOutputsAnalogGet Get the current settings of the analog output

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsAnalogGetRequest
*/
func (a *AudioAPIService) ApiAudioOutputsAnalogGet(ctx context.Context) ApiApiAudioOutputsAnalogGetRequest {
	return ApiApiAudioOutputsAnalogGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioOutputsAnalogGet200Response
func (a *AudioAPIService) ApiAudioOutputsAnalogGetExecute(r ApiApiAudioOutputsAnalogGetRequest) (*ApiAudioOutputsAnalogGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioOutputsAnalogGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsAnalogGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/analog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioOutputsAnalogPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioOutputsAnalogPutRequest *ApiAudioOutputsAnalogPutRequest
}

func (r ApiApiAudioOutputsAnalogPutRequest) ApiAudioOutputsAnalogPutRequest(apiAudioOutputsAnalogPutRequest ApiAudioOutputsAnalogPutRequest) ApiApiAudioOutputsAnalogPutRequest {
	r.apiAudioOutputsAnalogPutRequest = &apiAudioOutputsAnalogPutRequest
	return r
}

func (r ApiApiAudioOutputsAnalogPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioOutputsAnalogPutExecute(r)
}

/*
ApiAudioOutputsAnalogPut Set the analog output settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsAnalogPutRequest
*/
func (a *AudioAPIService) ApiAudioOutputsAnalogPut(ctx context.Context) ApiApiAudioOutputsAnalogPutRequest {
	return ApiApiAudioOutputsAnalogPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioOutputsAnalogPutExecute(r ApiApiAudioOutputsAnalogPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsAnalogPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/analog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioOutputsAnalogPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioOutputsDanteFarEndGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioOutputsDanteFarEndGetRequest) Execute() (*ApiAudioOutputsDanteFarEndGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioOutputsDanteFarEndGetExecute(r)
}

/*
ApiAudioOutputsDanteFarEndGet Get the current settings of the far end output

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsDanteFarEndGetRequest
*/
func (a *AudioAPIService) ApiAudioOutputsDanteFarEndGet(ctx context.Context) ApiApiAudioOutputsDanteFarEndGetRequest {
	return ApiApiAudioOutputsDanteFarEndGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioOutputsDanteFarEndGet200Response
func (a *AudioAPIService) ApiAudioOutputsDanteFarEndGetExecute(r ApiApiAudioOutputsDanteFarEndGetRequest) (*ApiAudioOutputsDanteFarEndGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioOutputsDanteFarEndGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsDanteFarEndGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/dante/farEnd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioOutputsDanteFarEndPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioOutputsDanteFarEndPutRequest *ApiAudioOutputsDanteFarEndPutRequest
}

func (r ApiApiAudioOutputsDanteFarEndPutRequest) ApiAudioOutputsDanteFarEndPutRequest(apiAudioOutputsDanteFarEndPutRequest ApiAudioOutputsDanteFarEndPutRequest) ApiApiAudioOutputsDanteFarEndPutRequest {
	r.apiAudioOutputsDanteFarEndPutRequest = &apiAudioOutputsDanteFarEndPutRequest
	return r
}

func (r ApiApiAudioOutputsDanteFarEndPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioOutputsDanteFarEndPutExecute(r)
}

/*
ApiAudioOutputsDanteFarEndPut Set the far end output settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsDanteFarEndPutRequest
*/
func (a *AudioAPIService) ApiAudioOutputsDanteFarEndPut(ctx context.Context) ApiApiAudioOutputsDanteFarEndPutRequest {
	return ApiApiAudioOutputsDanteFarEndPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioOutputsDanteFarEndPutExecute(r ApiApiAudioOutputsDanteFarEndPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsDanteFarEndPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/dante/farEnd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioOutputsDanteFarEndPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioOutputsDanteLocalGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioOutputsDanteLocalGetRequest) Execute() (*ApiAudioOutputsDanteLocalGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioOutputsDanteLocalGetExecute(r)
}

/*
ApiAudioOutputsDanteLocalGet Get the current settings of the local output

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsDanteLocalGetRequest
*/
func (a *AudioAPIService) ApiAudioOutputsDanteLocalGet(ctx context.Context) ApiApiAudioOutputsDanteLocalGetRequest {
	return ApiApiAudioOutputsDanteLocalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioOutputsDanteLocalGet200Response
func (a *AudioAPIService) ApiAudioOutputsDanteLocalGetExecute(r ApiApiAudioOutputsDanteLocalGetRequest) (*ApiAudioOutputsDanteLocalGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioOutputsDanteLocalGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsDanteLocalGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/dante/local"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioOutputsDanteLocalPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioOutputsDanteLocalPutRequest *ApiAudioOutputsDanteLocalPutRequest
}

func (r ApiApiAudioOutputsDanteLocalPutRequest) ApiAudioOutputsDanteLocalPutRequest(apiAudioOutputsDanteLocalPutRequest ApiAudioOutputsDanteLocalPutRequest) ApiApiAudioOutputsDanteLocalPutRequest {
	r.apiAudioOutputsDanteLocalPutRequest = &apiAudioOutputsDanteLocalPutRequest
	return r
}

func (r ApiApiAudioOutputsDanteLocalPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioOutputsDanteLocalPutExecute(r)
}

/*
ApiAudioOutputsDanteLocalPut Set the local output settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsDanteLocalPutRequest
*/
func (a *AudioAPIService) ApiAudioOutputsDanteLocalPut(ctx context.Context) ApiApiAudioOutputsDanteLocalPutRequest {
	return ApiApiAudioOutputsDanteLocalPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioOutputsDanteLocalPutExecute(r ApiApiAudioOutputsDanteLocalPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsDanteLocalPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/dante/local"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioOutputsDanteLocalPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioOutputsGlobalMuteGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioOutputsGlobalMuteGetRequest) Execute() (*ApiAudioOutputsGlobalMuteGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioOutputsGlobalMuteGetExecute(r)
}

/*
ApiAudioOutputsGlobalMuteGet Get the mute status of the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsGlobalMuteGetRequest
*/
func (a *AudioAPIService) ApiAudioOutputsGlobalMuteGet(ctx context.Context) ApiApiAudioOutputsGlobalMuteGetRequest {
	return ApiApiAudioOutputsGlobalMuteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioOutputsGlobalMuteGet200Response
func (a *AudioAPIService) ApiAudioOutputsGlobalMuteGetExecute(r ApiApiAudioOutputsGlobalMuteGetRequest) (*ApiAudioOutputsGlobalMuteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioOutputsGlobalMuteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsGlobalMuteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/global/mute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioOutputsGlobalMutePutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioOutputsGlobalMutePutRequest *ApiAudioOutputsGlobalMutePutRequest
}

func (r ApiApiAudioOutputsGlobalMutePutRequest) ApiAudioOutputsGlobalMutePutRequest(apiAudioOutputsGlobalMutePutRequest ApiAudioOutputsGlobalMutePutRequest) ApiApiAudioOutputsGlobalMutePutRequest {
	r.apiAudioOutputsGlobalMutePutRequest = &apiAudioOutputsGlobalMutePutRequest
	return r
}

func (r ApiApiAudioOutputsGlobalMutePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioOutputsGlobalMutePutExecute(r)
}

/*
ApiAudioOutputsGlobalMutePut Mute all audio outputs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioOutputsGlobalMutePutRequest
*/
func (a *AudioAPIService) ApiAudioOutputsGlobalMutePut(ctx context.Context) ApiApiAudioOutputsGlobalMutePutRequest {
	return ApiApiAudioOutputsGlobalMutePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioOutputsGlobalMutePutExecute(r ApiApiAudioOutputsGlobalMutePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioOutputsGlobalMutePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/outputs/global/mute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioOutputsGlobalMutePutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAudioRoomInUseActivityLevelGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioRoomInUseActivityLevelGetRequest) Execute() (*ApiAudioRoomInUseActivityLevelGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioRoomInUseActivityLevelGetExecute(r)
}

/*
ApiAudioRoomInUseActivityLevelGet Get the current room in use activity level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioRoomInUseActivityLevelGetRequest
*/
func (a *AudioAPIService) ApiAudioRoomInUseActivityLevelGet(ctx context.Context) ApiApiAudioRoomInUseActivityLevelGetRequest {
	return ApiApiAudioRoomInUseActivityLevelGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioRoomInUseActivityLevelGet200Response
func (a *AudioAPIService) ApiAudioRoomInUseActivityLevelGetExecute(r ApiApiAudioRoomInUseActivityLevelGetRequest) (*ApiAudioRoomInUseActivityLevelGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioRoomInUseActivityLevelGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioRoomInUseActivityLevelGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/roomInUse/activityLevel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioRoomInUseConfigGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioRoomInUseConfigGetRequest) Execute() (*ApiAudioRoomInUseConfigGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioRoomInUseConfigGetExecute(r)
}

/*
ApiAudioRoomInUseConfigGet Get the configuration of the room in use feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioRoomInUseConfigGetRequest
*/
func (a *AudioAPIService) ApiAudioRoomInUseConfigGet(ctx context.Context) ApiApiAudioRoomInUseConfigGetRequest {
	return ApiApiAudioRoomInUseConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioRoomInUseConfigGet200Response
func (a *AudioAPIService) ApiAudioRoomInUseConfigGetExecute(r ApiApiAudioRoomInUseConfigGetRequest) (*ApiAudioRoomInUseConfigGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioRoomInUseConfigGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioRoomInUseConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/roomInUse/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioRoomInUseGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioRoomInUseGetRequest) Execute() (*ApiAudioRoomInUseGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioRoomInUseGetExecute(r)
}

/*
ApiAudioRoomInUseGet Get the current room in use state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioRoomInUseGetRequest
*/
func (a *AudioAPIService) ApiAudioRoomInUseGet(ctx context.Context) ApiApiAudioRoomInUseGetRequest {
	return ApiApiAudioRoomInUseGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioRoomInUseGet200Response
func (a *AudioAPIService) ApiAudioRoomInUseGetExecute(r ApiApiAudioRoomInUseGetRequest) (*ApiAudioRoomInUseGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioRoomInUseGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioRoomInUseGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/roomInUse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioVoiceLiftGetRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
}

func (r ApiApiAudioVoiceLiftGetRequest) Execute() (*ApiAudioVoiceLiftGet200Response, *http.Response, error) {
	return r.ApiService.ApiAudioVoiceLiftGetExecute(r)
}

/*
ApiAudioVoiceLiftGet Get the current voice lift settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioVoiceLiftGetRequest
*/
func (a *AudioAPIService) ApiAudioVoiceLiftGet(ctx context.Context) ApiApiAudioVoiceLiftGetRequest {
	return ApiApiAudioVoiceLiftGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiAudioVoiceLiftGet200Response
func (a *AudioAPIService) ApiAudioVoiceLiftGetExecute(r ApiApiAudioVoiceLiftGetRequest) (*ApiAudioVoiceLiftGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAudioVoiceLiftGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioVoiceLiftGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/voiceLift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAudioVoiceLiftPutRequest struct {
	ctx context.Context
	ApiService *AudioAPIService
	apiAudioVoiceLiftPutRequest *ApiAudioVoiceLiftPutRequest
}

func (r ApiApiAudioVoiceLiftPutRequest) ApiAudioVoiceLiftPutRequest(apiAudioVoiceLiftPutRequest ApiAudioVoiceLiftPutRequest) ApiApiAudioVoiceLiftPutRequest {
	r.apiAudioVoiceLiftPutRequest = &apiAudioVoiceLiftPutRequest
	return r
}

func (r ApiApiAudioVoiceLiftPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiAudioVoiceLiftPutExecute(r)
}

/*
ApiAudioVoiceLiftPut Set the current voice lift settings

Set the current voice lift settings. Can be applied to the local output with the `voiceLiftEnabled` property.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAudioVoiceLiftPutRequest
*/
func (a *AudioAPIService) ApiAudioVoiceLiftPut(ctx context.Context) ApiApiAudioVoiceLiftPutRequest {
	return ApiApiAudioVoiceLiftPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AudioAPIService) ApiAudioVoiceLiftPutExecute(r ApiApiAudioVoiceLiftPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudioAPIService.ApiAudioVoiceLiftPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/audio/voiceLift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAudioVoiceLiftPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

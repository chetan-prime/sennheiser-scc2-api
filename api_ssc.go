/*
TCC M 3rd party API Release

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.6
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SSCAPIService SSCAPI service
type SSCAPIService service

type ApiApiSscSchemaGetRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
}

func (r ApiApiSscSchemaGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApiSscSchemaGetExecute(r)
}

/*
ApiSscSchemaGet Get the address tree

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiSscSchemaGetRequest
*/
func (a *SSCAPIService) ApiSscSchemaGet(ctx context.Context) ApiApiSscSchemaGetRequest {
	return ApiApiSscSchemaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SSCAPIService) ApiSscSchemaGetExecute(r ApiApiSscSchemaGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscSchemaGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/openapi+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSscStateSubscriptionsGetRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
}

func (r ApiApiSscStateSubscriptionsGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApiSscStateSubscriptionsGetExecute(r)
}

/*
ApiSscStateSubscriptionsGet Start a subscription

Start a subscription. A successful request returns a UUID that can be used to manage the created subscription. The ``/ssc/state`` address is specific to the session between client and server. This means that it is possible that different clients subscribe the same command with different arguments hence the immediate reply as well as the resulting state of the server will differ for each client respectively. This also means, that there can be only a limited number of sessions per client and user. Instead of generating new subscriptions the "old" subscription should be altered.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiSscStateSubscriptionsGetRequest
*/
func (a *SSCAPIService) ApiSscStateSubscriptionsGet(ctx context.Context) ApiApiSscStateSubscriptionsGetRequest {
	return ApiApiSscStateSubscriptionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SSCAPIService) ApiSscStateSubscriptionsGetExecute(r ApiApiSscStateSubscriptionsGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscStateSubscriptionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/state/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
	sessionUUID string
	requestBody *[]string
}

func (r ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest) RequestBody(requestBody []string) ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiSscStateSubscriptionsSessionUUIDAddPutExecute(r)
}

/*
ApiSscStateSubscriptionsSessionUUIDAddPut Add resource(s) to the subscription list

Add a set of resources to the list of subscriptions associated with the sessionUUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionUUID
 @return ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest
*/
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDAddPut(ctx context.Context, sessionUUID string) ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest {
	return ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest{
		ApiService: a,
		ctx: ctx,
		sessionUUID: sessionUUID,
	}
}

// Execute executes the request
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDAddPutExecute(r ApiApiSscStateSubscriptionsSessionUUIDAddPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscStateSubscriptionsSessionUUIDAddPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/state/subscriptions/{sessionUUID}/add"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionUUID"+"}", url.PathEscape(parameterValueToString(r.sessionUUID, "sessionUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiSscStateSubscriptionsSessionUUIDAddPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiSscStateSubscriptionsSessionUUIDDeleteRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
	sessionUUID string
}

func (r ApiApiSscStateSubscriptionsSessionUUIDDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiSscStateSubscriptionsSessionUUIDDeleteExecute(r)
}

/*
ApiSscStateSubscriptionsSessionUUIDDelete End an existing subscription

End the subscription associated with the sessionUUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionUUID
 @return ApiApiSscStateSubscriptionsSessionUUIDDeleteRequest
*/
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDDelete(ctx context.Context, sessionUUID string) ApiApiSscStateSubscriptionsSessionUUIDDeleteRequest {
	return ApiApiSscStateSubscriptionsSessionUUIDDeleteRequest{
		ApiService: a,
		ctx: ctx,
		sessionUUID: sessionUUID,
	}
}

// Execute executes the request
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDDeleteExecute(r ApiApiSscStateSubscriptionsSessionUUIDDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscStateSubscriptionsSessionUUIDDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/state/subscriptions/{sessionUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionUUID"+"}", url.PathEscape(parameterValueToString(r.sessionUUID, "sessionUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiSscStateSubscriptionsSessionUUIDGetRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
	sessionUUID string
}

func (r ApiApiSscStateSubscriptionsSessionUUIDGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ApiSscStateSubscriptionsSessionUUIDGetExecute(r)
}

/*
ApiSscStateSubscriptionsSessionUUIDGet Get the subscription list

Get the list of subscriptions associated with the sessionUUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionUUID
 @return ApiApiSscStateSubscriptionsSessionUUIDGetRequest
*/
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDGet(ctx context.Context, sessionUUID string) ApiApiSscStateSubscriptionsSessionUUIDGetRequest {
	return ApiApiSscStateSubscriptionsSessionUUIDGetRequest{
		ApiService: a,
		ctx: ctx,
		sessionUUID: sessionUUID,
	}
}

// Execute executes the request
//  @return []string
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDGetExecute(r ApiApiSscStateSubscriptionsSessionUUIDGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscStateSubscriptionsSessionUUIDGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/state/subscriptions/{sessionUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionUUID"+"}", url.PathEscape(parameterValueToString(r.sessionUUID, "sessionUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSscStateSubscriptionsSessionUUIDPutRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
	sessionUUID string
	requestBody *[]string
}

func (r ApiApiSscStateSubscriptionsSessionUUIDPutRequest) RequestBody(requestBody []string) ApiApiSscStateSubscriptionsSessionUUIDPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiSscStateSubscriptionsSessionUUIDPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiSscStateSubscriptionsSessionUUIDPutExecute(r)
}

/*
ApiSscStateSubscriptionsSessionUUIDPut Set or change the list of subscriptions associated with the sessionUUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionUUID
 @return ApiApiSscStateSubscriptionsSessionUUIDPutRequest
*/
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDPut(ctx context.Context, sessionUUID string) ApiApiSscStateSubscriptionsSessionUUIDPutRequest {
	return ApiApiSscStateSubscriptionsSessionUUIDPutRequest{
		ApiService: a,
		ctx: ctx,
		sessionUUID: sessionUUID,
	}
}

// Execute executes the request
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDPutExecute(r ApiApiSscStateSubscriptionsSessionUUIDPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscStateSubscriptionsSessionUUIDPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/state/subscriptions/{sessionUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionUUID"+"}", url.PathEscape(parameterValueToString(r.sessionUUID, "sessionUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
	sessionUUID string
	requestBody *[]string
}

func (r ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest) RequestBody(requestBody []string) ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiSscStateSubscriptionsSessionUUIDRemovePutExecute(r)
}

/*
ApiSscStateSubscriptionsSessionUUIDRemovePut Remove resource(s) from the subscription list

Remove a set of resources from the list of subscriptions associated with the sessionUUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionUUID
 @return ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest
*/
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDRemovePut(ctx context.Context, sessionUUID string) ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest {
	return ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest{
		ApiService: a,
		ctx: ctx,
		sessionUUID: sessionUUID,
	}
}

// Execute executes the request
func (a *SSCAPIService) ApiSscStateSubscriptionsSessionUUIDRemovePutExecute(r ApiApiSscStateSubscriptionsSessionUUIDRemovePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscStateSubscriptionsSessionUUIDRemovePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/state/subscriptions/{sessionUUID}/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionUUID"+"}", url.PathEscape(parameterValueToString(r.sessionUUID, "sessionUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiSscStateSubscriptionsSessionUUIDRemovePut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiSscVersionGetRequest struct {
	ctx context.Context
	ApiService *SSCAPIService
}

func (r ApiApiSscVersionGetRequest) Execute() (*ApiSscVersionGet200Response, *http.Response, error) {
	return r.ApiService.ApiSscVersionGetExecute(r)
}

/*
ApiSscVersionGet Get the schema version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiSscVersionGetRequest
*/
func (a *SSCAPIService) ApiSscVersionGet(ctx context.Context) ApiApiSscVersionGetRequest {
	return ApiApiSscVersionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiSscVersionGet200Response
func (a *SSCAPIService) ApiSscVersionGetExecute(r ApiApiSscVersionGetRequest) (*ApiSscVersionGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiSscVersionGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSCAPIService.ApiSscVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ssc/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
